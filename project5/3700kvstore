#!/usr/bin/python3 -u
import argparse
import socket
import select
import time
import json
import random
import threading
from enum import Enum

# ----------------------------- GLOBAL VARIABLES -----------------------------

MAX_BYTES = 32768
HEARTBEAT_FREQ = 0.5 # seconds, or 500 milliseconds

# ------------------------- END OF GLOBALS VARIABLES -------------------------

def current_time():
    """Returns the current time in seconds"""
    return time.time()


class State(Enum):
    """Represents the possible server states at any given time"""
    LEADER = 1
    FOLLOWER = 2
    CANDIDATE = 3


class Sock:
    def __init__(self, lan):
        self.sock = self.__create_socket(lan) # socket over which all messages will occur

    def __create_socket(self, lan):
        """Creates and returns a connected socket"""
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        sock.connect(lan)
        return sock

    def recv(self):
        """Returns the data from the socket as a deserialized JSON object"""
        msg_raw = self.sock.recv(MAX_BYTES)
        msg = json.loads(bytes.decode(msg_raw)) if len(msg_raw) != 0 else {}
        return msg

    def send(self, msg):
        """Sends a JSON object through the socket"""
        print('{src} sending a NOOP to {dst}'.format(src=msg['src'], dst=msg['dst']))
        msg = str.encode(json.dumps(msg))
        self.sock.send(msg)


class Server:
    def __init__(self, id, replicas):
        self.id = id # own ID
        self.replicas = replicas # IDs of all other replicas
        self.sock = Sock(id) # Sock object for sending/receiving messsages
        self.state = State.FOLLOWER # current state; initialized to follower
        self.leader = None

        # ---------------------- PERSISTENT STATE (ALL) -----------------------
        self.current_term = 0 # latest term server has seen
        self.voted_for = None # ID of candidate that received vote in current term
        self.log = [] # log entries

        # ----------------------- VOLATILE STATE (ALL) ------------------------
        self.commit_idx = 0 # index of highest log entry known to be committed
        self.last_applied = 0 # index of highest log entry applied to state machine

        # --------------------- VOLATILE STATE (LEADER) -----------------------
        self.next_idx = {} # index of next log entry to send to each server
        self.match_idx = {} # index of highest log entry known on each server

        # Start heartbeat thread
        threading.Thread(target=self.send_heartbeat).start()

    def send_heartbeat(self):
        """Sends periodic heartbeats as the leader"""
        while True:
            if self.state == State.LEADER:
                for replica in self.replicas:
                    msg = {
                        'src': self.id, 
                        'dst': replica,
                        'leader': self.leader, 
                        'type': 'heartbeat'
                    }
            time.sleep(HEARTBEAT_FREQ) 

    def run(self):
        """Runs the main loop"""
        last = 0
        while True:
            ready = select.select([self.sock.sock], [], [], 0.1)[0]
        
            if self.sock.sock in ready:
                msg = self.sock.recv()
                
                if not msg:
                    continue
                
                # For now, ignore get() and put() from clients
                if msg['type'] in ['get', 'put']:
                    pass
      
                # Handle noop messages. This may be removed from your final implementation
                elif msg['type'] == 'noop':
                    print('{dst} received a NOOP from {src}'.format(dst=msg['dst'], src=msg['src']))
       	
            clock = current_time()
            if clock - last > 2:
                # Send a no-op message to a random peer every two seconds, just for fun
                # You definitely want to remove this from your implementation
                msg = {
                    'src': self.id, 
                    'dst': random.choice(self.replicas), 
                    'leader': 'FFFF', 
                    'type': 'noop'
                }
                self.sock.send(msg)
                last = clock
 

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Key-Value Store.', 
                                     add_help=False)
    parser.add_argument('id',
                        help='ID of your replica (four-digit hex)')
    parser.add_argument('replicas',
                        nargs='+',
                        help='IDs of all other replicas (four-digit hexs)')
    args = parser.parse_args()

    # Initialize the datastore with the arguments passed
    server = Server(args.id, args.replicas)

    # Start the program
    server.run()
