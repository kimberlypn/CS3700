#!/usr/bin/python3 -u
import argparse
import collections
import enum
import json
import logging
import math
import os
import random
import select
import socket
import threading
import time

import myutils

# ----------------------------- GLOBAL VARIABLES -----------------------------

MAX_BYTES = 32768 # maximum bytes to read in from the socket
HEARTBEAT_FREQ = 0.1 # seconds, or 100 milliseconds

# ------------------------- END OF GLOBALS VARIABLES -------------------------

def current_time():
    """Returns the current time in seconds"""
    return time.time()


class State(enum.Enum):
    """Represents the possible server states at any given time"""
    LEADER = 1
    FOLLOWER = 2
    CANDIDATE = 3


class SimulatorSocket:
    ''' The simulator uses unix ports to interface instances of this program
        with each other. All messages are stringifyed JSON objects.'''
    def __init__(self, lan):
        self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        self.sock.connect(lan)

        self.poll = select.poll()
        self.poll.register(self.sock.fileno(), select.POLLIN)

    def recv(self, timeout=None):
        """Returns the data from the socket as a deserialized JSON object"""
        if self.poll.poll(timeout):
            msg_raw = self.sock.recv(MAX_BYTES)
            msg = json.loads(bytes.decode(msg_raw)) if len(msg_raw) != 0 else {}
            return msg
        else:
            return None

    def send(self, msg):
        """Sends a JSON object through the socket"""
        msg = json.dumps(msg).encode()
        self.sock.send(msg)


class LoggingMixin:
    LogEntry = collections.namedtuple('LogEntry', 'logfunc string')

    def _logfmt(self, string):
        return '{}::{} {}'.format(self.state, self.current_term, string)

    def _logfunc_or_enque(self, logfunc, string):
        msg = self._logfmt(string)
        log =  getattr(self, '_logging_log', None)
        if log is not None:
            log.append(LoggingMixin.LogEntry(logfunc, msg))
        else:
            logfunc(msg)

    def info(self, string):
        self._logfunc_or_enque(logging.info, string)

    def debug(self, string):
        self._logfunc_or_enque(logging.debug, string)
    
    class BypassProxy:
        def __init__(self, instance):
            self.instance = instance

        def info(self, string):
            logging.info(self.instance._logfmt(string))

        def debug(self, string):
            logging.debug(self.instance._logfmt(string))

    class Accumulator:
        def __init__(self, instance):
            self.instance = instance

        def __enter__(self):
            # Kind of a NOP but should allow for nested log surpression
            self.previous_log = getattr(self.instance, '_logging_log', None)
            self.instance._logging_log = []
            return LoggingMixin.BypassProxy(self.instance)

        def __exit__(self, *args):
            for e in self.instance._logging_log:
                e.logfunc(e.string)
            self.instance._logging_log = self.previous_log

    def accumulate_logs(self):
        return LoggingMixin.Accumulator(self)


class Server(LoggingMixin):
    def __init__(self, id_, replicas):
        self.id = id_
        self.replicas = replicas 
        self.sock = SimulatorSocket(self.id)
        self.datastore = {} # state machine containing all key-value pairs
        self.reset_timeouts()

        # ---------------------- PERSISTENT STATE (ALL) -----------------------
        self.current_term = 0 # latest term server has seen
        self.voted_for = None # ID of candidate that received vote in current term
        # log entries; each entry contains command and term (first index is 1)
        self.log = [{'command': None, 'term': 0}]

        # ----------------------- VOLATILE STATE (ALL) ------------------------
        self.commit_idx = 0 # index of highest log entry known to be committed
        self.last_applied = 0 # index of highest log entry applied to state machine

        # --------------------- VOLATILE STATE (LEADER) -----------------------
        self.next_idx = {} # index of next log entry to send to each server
        self.match_idx = {} # index of highest log entry known on each server
        self.prev_heartbeat = current_time() # timestamp of previous heartbeat

        self.state = None
        self.leader = 'FFFF'
        self.failed = set() #Just for logging
        self.transition_to_state(State.FOLLOWER)

    @property
    def last_log_idx(self):
        return len(self.log) - 1

    @property
    def last_log_term(self):
        return self.log[-1]['term']

    @property
    def first_uncommitted_idx(self):
        return self.commit_idx + 1

    @property
    def uncomitted_entries(self):
        return self.log[self.first_uncommitted_idx:]

    @property
    def n(self):
        return len(self.replicas) + 1

    @property
    def quorum(self):
        return self.n // 2 + 1
    
    def transition_to_state(self, state, msg=None, term=None):
        prev_state = self.state
        prev_term = self.current_term
        with self.accumulate_logs() as bypass_log:
            # We don't want to have dangling clients waiting on our
            # leader if the leader transitions away from leading
            if self.state == State.LEADER:
                if self.uncomitted_entries:
                    labels = ['{}.{}'.format(e['src'], e['command'])
                            for e in self.uncomitted_entries]
                    self.debug('Leaving leader state, sending Fail to {}'.format(labels))
                    for e in self.uncomitted_entries:
                        self.send_fail_entry(e)

            if state == State.LEADER:
                self.debug('Voted for by {}'.format(str(list(self.votes))))
                # Re-initialize any necessary fields
                self.state = State.LEADER
                self.leader = self.id
                self.prev_heartbeat = current_time()
                for replica in self.replicas:
                    # For each server, index of next log entry to send to that server
                    # (initialized to leader last log index + 1)
                    self.next_idx[replica] = self.commit_idx + 1
                    # For each server, index of highest log entry known to be 
                    # replicated on server (initialized to 0, increases monotonically)
                    self.match_idx[replica] = 0
    
                self.broadcast_heartbeat()
                
            elif state == State.FOLLOWER:
                if self.failed:
                    bypass_log.info('Failed {}'.format(self.failed))
                self.state = State.FOLLOWER
                if msg:
                    self.leader = msg['leader']
                    self.current_term = msg['term']
                self.votes = set()
                self.failed = set()
                self.voted_for = None
    
            elif state == State.CANDIDATE:
                self.state = State.CANDIDATE
                self.leader = 'FFFF' # ID of the assumed leader
                self.reset_timeouts()
                if term is None:
                    self.current_term += 1
                else:
                    self.current_term = term
                # Reset any votes from a previous election
                self.votes = set((self.id,))
                # Vote for self
                self.voted_for = self.id
                
            else:
                #TODO define a proper exception
                raise 1

            if self.state != prev_state or self.current_term != prev_term:
                bypass_log.info('<- {}::{}'.format(prev_state, prev_term))


    def check_timeout(self):
        """Determines if an election needs to take place"""
        time = current_time()

        if self.state != State.LEADER:
            return (time - self.prev_timeout) >= self.election_timeout
        else:
            return False

    def reset_timeouts(self):
        """Resets the election and leader timeouts"""
        self.election_timeout = random.uniform(0.15, 0.3)
        self.prev_timeout = current_time()


    def send(self, dst, **kwargs):
        """
        Sends a message through the socket, ensuring that the required
        fields are included
        """
        msg = kwargs.copy()
        msg.update(**{
            'src': self.id,
            'dst': dst,
            'leader': self.leader,
            'term': self.current_term
        })
        self.debug('Replica ' + self.id + ' sending ' + json.dumps(msg))
        self.sock.send(msg)
        
    def reply(self, msg, **kwargs):
        """Sends a reply to the source"""
        mymsg = msg.copy()
        mymsg.update(**kwargs)
        mymsg['src'] = msg['dst']
        mymsg['dst'] = msg['src']
        self.send(**mymsg)

    def send_redirect(self, msg):
        """Sends a redirect message back to the source"""
        self.reply(msg, type='redirect')

    def send_ok(self, msg, **kwargs):
        """Sends an OK message back to the source"""
        self.reply(msg, type='ok', **kwargs)

    def send_fail(self, msg):
        """Sends a fail message back to the source"""
        self.reply(msg, type='fail')

    def send_ok_entry(self, entry):
        self.info('Sending {}.{}({}, {}) OK'.format(entry['src'], entry['command'],
                entry['key'], entry['value']))
        self.send_ok({'dst': self.id, 'src': entry['src'], 'MID': entry['MID']})

    def send_fail_entry(self, entry):
        self.info('Sending {}.{}({}, {}) FAIL'.format(entry['src'], entry['command'],
                entry['key'], entry['value']))
        self.send_fail({'dst': self.id, 'src': entry['src'], 'MID': entry['MID']})

    @myutils.FunctionDispatcher.decorate
    def dispatch(self, key, *args, **kwargs):
        pass

    def broadcast_heartbeat(self):
        """Sends a heartbeat to all of the replicas"""
        for replica in self.replicas:
            self.send_append_entries(replica, 
                    prev_log_idx=self.last_log_idx, 
                    prev_log_term=self.last_log_term)

    # --------------------------- REQUEST VOTES RPC ---------------------------

    def send_request_vote(self):
        """Sends RequestVote RPCs to all other servers"""
        for replica in self.replicas:
            self.send(replica, **{
                'type': 'request_vote',
                # Index of candidate's last log entry
                'last_log_idx': self.last_log_idx,
                # Term of candidate's last log entry
                'last_log_term': self.last_log_term
            })

    def msg_up_to_date(self, msg):
        """
        Determines if candidate's log is at least as up-to-date 
        as receiver's log
        """
        # If the logs have last entries with different terms, then 
        # the log with the later term is more up-to-date.
        if self.last_log_term != msg['last_log_term']:
            return self.last_log_term <= msg['last_log_term']
        # If the logs end with the same term, then whichever log 
        # is longer is more up-to-date.
        else:
            return self.last_log_idx <= msg['last_log_idx']

    @dispatch.add('request_vote')
    def handle_request_vote(self, msg):
        """Handles a RequestVote RPC from a candidate"""
        def reject(hint=''):
            self.info('Rejecting {}.request_vote ({})'.format(msg['src'], hint))
            self.reply(msg, type='response_vote', value='false')

        # Reply false if term < currentTerm
        if msg['term'] < self.current_term:
            reject('Term {}<{}'.format(msg['src'], msg['term'], self.current_term))
        # If votedFor is null or candidateId, and candidate’s log is at
        # least as up-to-date as receiver’s log, grant vote
        else:
            if self.msg_up_to_date(msg):
                if self.voted_for is None or self.voted_for == msg['src']:
                    self.voted_for = msg['src']
                    self.info('Term {} Voted for {}'.format(self.current_term,
                            self.voted_for))
                    self.reply(msg, type='response_vote', value='true')
                    self.reset_timeouts()
                else:
                    reject('already voted this term')
            else:
                reject('replica log out of date')

    @dispatch.add('response_vote')
    def handle_received_vote(self, msg):
        """Handles a received vote during an election"""
        if msg['value'] == 'true':
            self.votes.add(msg['src'])
            # If votes received from majority of servers: become leader
            if len(self.votes) >= self.quorum:
                self.transition_to_state(State.LEADER)

    # ------------------------ END OF REQUEST VOTES RPC -----------------------

    # --------------------------- APPEND ENTRIES RPC --------------------------

    def send_append_entries(self, replica, entries=None, prev_log_term=0, prev_log_idx=0):
        """Sends an AppendEntries RPC to a replica"""
        self.send(replica, **{
            'type': 'append_entries',
            # Term of prev_log_idx entry
            'prev_log_term': prev_log_term,
            # Index of log entry immediately preceeding new ones
            'prev_log_idx': prev_log_idx,
            'entries': entries if entries is not None else [],
            'leader_commit': self.commit_idx
        })

    def try_append_entries(self, replica):
        # Adhering to RAFT ensures that the leader will always have
        # the longest log, no worries about prev_log_idx being out
        # of bounds

        # Tempting to use match_idx, but that is initialized to 0
        prev_idx = self.next_idx[replica] - 1
        prev_term = self.log[prev_idx]['term']
        entries = self.log[prev_idx + 1:]
        entries = entries[:100]

        self.info('Sending {}.AppendEntries[{}:{}]'.format(replica,
            self.next_idx[replica], len(self.log)))
        self.send_append_entries(
            replica, 
            # Log entries to store
            entries, 
            # Term of highest log entry known to be replicated on the server
            prev_term, 
            # Index of highest log entry known to be replicated on the server
            prev_idx
        ) 

    def broadcast_append_entries(self):
        """Sends an AppendEntries RPC to all replicas"""
        for replica in self.replicas:
            self.try_append_entries(replica)
        
    @dispatch.add('append_entries')
    def handle_append_entries(self, msg):
        """Handles an AppendEntries RPC from a leader"""
        prev_log_idx = msg['prev_log_idx']
        prev_log_term = msg['prev_log_term']

        def reject(string):
            self.info('Failing {}.append_entries ({})'.format(msg['src'], string))
            self.send_fail(msg)

        # If server receives request with stale term number,
        # it rejects the request
        if msg['term'] < self.current_term:
            reject('term {}<{}'.format(self.current_term, msg['term']))
        # If leader's term is equal to or greater than server's term, 
        # then leader had to have been properly elected and, therefore,
        # is safe to follow
        else:
            # If RPC request or response contains term T > currentTerm: 
            # set currentTerm = T, convert to follower
            self.transition_to_state(State.FOLLOWER, msg)
            self.reset_timeouts()

            # Reply false if log doesn’t contain an entry at prevLogIndex
            # whose term matches prevLogTerm
            if prev_log_idx > self.last_log_idx:
                reject('index {}>{}'.format(prev_log_idx, self.last_log_idx))
            elif self.log[prev_log_idx]['term'] != prev_log_term:
                reject('prev term {}!={}'.format(self.log[prev_log_idx]['term'],
                        prev_log_term))
            else:
                if msg['entries']:
                    last = prev_log_idx + 1
                    # If an existing entry conflicts with a new one (same index
                    # but different terms), delete the existing entry and all
                    # that follow it
                    if last <= self.last_log_idx:
                        self.info('Deleting entries [{}:]'.format(last))
                        del self.log[last:]
                    self.info('Appending {} entries ({})'.format(len(msg['entries']),
                            [e['MID'] for e in msg['entries']]))
                    # Append any new entries not already in the log
                    self.log.extend(msg['entries'])
                # If leaderCommit > commitIndex, set commitIndex =
                # min(leaderCommit, index of last new entry)
                self.commit_idx = min(self.last_log_idx, msg['leader_commit'])
                self.send_ok(msg)

    @dispatch.add('ok')
    @dispatch.add('fail')
    def handle_appened_entries_resp(self, msg):
        if self.state == State.LEADER:
            if msg['type'] == 'ok':
                self.match_idx[msg['src']] = msg['prev_log_idx'] + len(msg['entries'])
                self.next_idx[msg['src']] = self.match_idx[msg['src']] + 1
                # given N replicas, N/2 + 1 form a quorum. If you sort the current
                # index each is on, the N//2 + 1'th index (middle index) is the one
                # which brings something into the majorty and commits it
                #
                # From this replicas persective, the message was already ready to
                # be comitted, so only need N//2 confirmations. Therfore the second
                # highest index is the one to mark comitted
                committed_idx = list(sorted(self.match_idx.values()))[-self.n//2]
                if self.commit_idx < committed_idx:
                    self.info('Committing entry {}'.format(self.commit_idx))
                    # If there exists an N such that N > commitIndex, a majority
                    # of matchIndex[i] ≥ N, and log[N].term == currentTerm: 
                    # set commitIndex = N
                    self.commit_idx = committed_idx
                    entry = self.log[self.commit_idx]
                    # Don't send OK to PUT/GET from an old term, when that leader
                    # was reliquished it sent a fail and the client retried
                    if entry['term'] == self.current_term:
                        self.send_ok_entry(entry)
            # If AppendEntries fails because of log inconsistency:
            # decrement nextIndex and retry
            elif msg['type'] == 'fail':
                self.next_idx[msg['src']] -= 1

                self.info('Decremeting {}.next_idx {}'.format(msg['src'],
                        self.next_idx[msg['src']]))
                self.try_append_entries(msg['src'])
            else:
                raise 1

    # ----------------------- END OF APPEND ENTRIES RPC -----------------------

    # --------------------------- CLIENT INTERFACE ----------------------------

    @dispatch.add('put')
    def handle_put(self, msg):
        """Handles a put request from the client"""
        if self.state != State.LEADER:
            # Send fail if leader unknown
            if self.leader == 'FFFF':
                self.failed.add('{}.put'.format(msg['src']))
                self.send_fail(msg)
            # Else, redirect to the leader
            else:
                self.info('{}.put redirected to {}'.format(msg['src'], self.leader))
                self.send_redirect(msg)
            return

        # Append entry to local log
        key = msg['key']
        value = msg['value']
        entry = {
            'command': 'put',
            'src': msg['src'],
            'MID': msg['MID'],
            'key': key,
            'value': value,
            'term': self.current_term
        }
        self.log.append(entry)
        self.broadcast_append_entries()

    @dispatch.add('get')
    def handle_get(self, msg):
        """Handles a get request from the client"""
        if self.state == State.LEADER:
            # Respond with the value if it exists
            self.send_ok(msg, value=self.datastore.get(msg['key'], ''))
        elif self.leader == 'FFFF':
            self.failed.add('{}.get'.format(msg['src']))
            self.send_fail(msg)
        else:
            self.info('{}.get redirected to {}'.format(msg['src'], self.leader))
            self.send_redirect(msg)

    def apply(self, entries):
        """Commits the entries to the state machine"""
        for e in entries:
            if e['command'] == 'put':
                self.datastore[e['key']] = e['value']

    def run(self):
        """Runs the main loop"""
        while True:
            time = current_time()
            # Leaders send empty AppendEntries RPCs (heartbeats) to each 
            # server during idle periods to prevent election timeouts
            if self.state == State.LEADER:
                span = time - self.prev_heartbeat
                if span >= HEARTBEAT_FREQ:
                    self.debug('Sent Heartbeat')
                    self.broadcast_heartbeat()
                    # Reset the heartbeat timer
                    self.prev_heartbeat = time

            # Election timeout met, so start election
            if self.check_timeout():
                self.transition_to_state(State.CANDIDATE)
                self.send_request_vote()

            # If commitIndex > lastApplied: increment lastApplied, 
            # apply log[lastApplied] to state machine
            if self.commit_idx > self.last_applied:
                if self.commit_idx - self.last_applied > 1:
                    self.info('Applying [{}, {}]'.format(self.last_applied + 1,
                            self.commit_idx))
                else:
                    self.info('Applying {}'.format(self.commit_idx))
                self.apply(self.log[self.last_applied+1:self.commit_idx + 1])
                self.last_applied = self.commit_idx

            msg = self.sock.recv(timeout=0.05)
            if msg:
                self.debug('Replica ' + self.id + ' recieved ' +json.dumps(msg))
                # If RPC request or response contains term T > currentTerm: 
                # set currentTerm = T, convert to follower 
                if 'term' in msg and self.current_term < msg['term']:
                    self.info('Reverting to FOLLOWER, Term {}.{} from {}'
                        .format(msg['term'], msg['type'], msg['src']))
                    self.transition_to_state(State.FOLLOWER, msg)
                    self.reset_timeouts()
                self.dispatch(msg['type'], msg)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Distributed Key-Value Store',
            add_help=False)
    parser.add_argument('id', help='ID of your replica (four-digit hex)')
    parser.add_argument('replicas',
            nargs='+', help='IDs of all other replicas (four-digit hexs)')
    args = parser.parse_args()

    if 'DEBUG_LEVEL' in os.environ:
        level = getattr(logging, os.environ['DEBUG_LEVEL'])
        logging.basicConfig(filename=args.id + '.log', filemode='w',
                level=level, datefmt='%M:%S',
                format='%(levelname)s %(asctime)s.%(msecs)03d: %(message)s')


    # Initialize the datastore with the arguments passed
    server = Server(args.id, args.replicas)
    server.run()
